"""
Stytch User Sync Middleware for Django

Syncs Stytch authenticated users to local database after session validation.
Implements the same logic as Spring Boot's StytchUserSyncFilter.

Note: Unlike Auth0/Okta JWT-based auth, Stytch session authentication
returns full user info directly from the SDK, so no userinfo fallback is needed.
"""

import os
import logging
import fnmatch
from django.conf import settings
from django.http import JsonResponse
from app_rbac.models import User, UserRole


logger = logging.getLogger(__name__)


class StytchUserSyncMiddleware:
    """
    Middleware that syncs Stytch users to the local database.

    Flow:
    1. Runs after Stytch session authentication (authentication.py)
    2. Checks if request has authenticated user (from Stytch)
    3. Extracts user information from StytchUser object
    4. Upserts user to database with role assignment
    5. Returns HTTP 500 if sync fails (fail fast)

    Environment variables for admin role assignment:
    - APP_USERS_ROOT: Single root user email (gets ROOT, ADMIN, USER roles)
    - APP_USERS_ADMINS: Comma-separated admin emails (get ADMIN, USER roles)
    """

    def __init__(self, get_response):
        self.get_response = get_response
        self.root_user = os.environ.get('APP_USERS_ROOT', '').strip()
        admins_str = os.environ.get('APP_USERS_ADMINS', '').strip()
        self.admin_users = [email.strip() for email in admins_str.split(',') if email.strip()]

    def __call__(self, request):
        # Skip public endpoints defined in settings.PUBLIC_URIS
        if self._is_public_path(request.path):
            return self.get_response(request)

        # Only sync if user is authenticated via Stytch
        # StytchUser has stytch_response attribute (unlike Auth0/Okta which have payload)
        if hasattr(request, 'user') and hasattr(request.user, 'stytch_response'):
            try:
                self._sync_user_to_database(request.user)
            except Exception as e:
                logger.error(f'Failed to sync Stytch user to database. Failing request: {str(e)}', exc_info=True)
                return JsonResponse(
                    {
                        'error': 'User synchronization failed',
                        'message': str(e)
                    },
                    status=500
                )

        return self.get_response(request)

    def _is_public_path(self, path):
        """
        Check if the given path matches any public URI pattern.
        Reads from settings.PUBLIC_URIS (list of URI patterns).
        """
        public_uris = getattr(settings, 'PUBLIC_URIS', [
            '/',
            '/api/v1/public/*',
            '/health',
            '/admin/*',
            '/static/*',
            '/media/*',
        ])

        for pattern in public_uris:
            # Convert pattern to fnmatch-compatible (simple wildcard matching)
            if fnmatch.fnmatch(path, pattern):
                return True
            # Also check exact match
            if path == pattern:
                return True

        return False

    def _sync_user_to_database(self, stytch_user):
        """
        Synchronize Stytch user to local database with role assignment.

        Args:
            stytch_user: StytchUser object from authentication.py
        """
        # Stytch returns full user info from session.authenticate() response
        # No need for userinfo fallback like Auth0/Okta
        email = stytch_user.email
        stytch_id = stytch_user.id  # user_id from session
        first_name = stytch_user.first_name
        last_name = stytch_user.last_name
        tenant_id = stytch_user.tenant_id

        # Picture is not directly on StytchUser, check claims
        picture = stytch_user.claims.get('picture') if stytch_user.claims else None

        if not email:
            raise ValueError('Email not available from Stytch authentication')

        logger.debug(f'Syncing Stytch user to database: email={email}, stytch_id={stytch_id}, tenant_id={tenant_id}')

        # Determine roles based on email
        roles = [UserRole.USER]
        if self.root_user and self.root_user.lower() == email.lower():
            logger.warning(f'Creating root user: {email}')
            roles = [UserRole.ROOT, UserRole.ADMIN, UserRole.USER]
        elif any(admin.lower() == email.lower() for admin in self.admin_users):
            logger.warning(f'Creating admin user: {email}')
            roles = [UserRole.ADMIN, UserRole.USER]

        # Upsert user to database
        user, created = User.objects.update_or_create(
            external_auth_provider='stytch',
            external_auth_id=stytch_id,
            defaults={
                'tenant_id': tenant_id,
                'username': email,  # Username same as email
                'email': email,
                'first_name': first_name,
                'last_name': last_name,
                'picture': picture,
                'enabled': True,
                'roles': roles,
                'deleted': False,
            }
        )

        action = 'Created' if created else 'Updated'
        logger.info(f'{action} user: {email} with roles: {roles}')
